     1	
     2	#include <stdio.h>
     3	#include <string.h>
     4	
     5	#define BuffSize (1024)
     6	#define MaxIndent (12)
     7	
     8	/* 
     9	 Change
    10	
    11	   12  This is a numbered line in a handout.
    12	 
    13	 to
    14	
    15	   This is a numbered line in a handout.
    16	*/
    17	int main() {
    18	  unsigned char buffer[BuffSize + 1];
    19	
    20	  while (fgets(buffer, BuffSize, stdin) != 0) {
    21	    unsigned char* ptr = buffer;
    22	    unsigned int n = 0;
    23	
    24	    while (isspace(*ptr)) ptr++;
    25	    while (isdigit(*ptr) && ++n < MaxIndent) ptr++;
    26	    if (*ptr == '\t') ptr++;
    27	    printf("%s", ptr);
    28	  }
    29	  return 0;
    30	}
    31	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32	
    33	
    34	#include <stdio.h>
    35	#include <setjmp.h>
    36	#include <stdlib.h>
    37	#include <signal.h>
    38	
    39	/* Define a jump buffer to handle error conditions.
    40	   Data type jmp_buf defined in setjmp.h.
    41	*/
    42	static jmp_buf env;       /* file scope, type jmp_buf is defined in setjmp.h */
    43	
    44	void jumper(int);         /* callback for SIGFPE errors */
    45	void divisionInt(void);   /* alternative to void divisionInt() */
    46	int guard(void);          /* guards divisonInt */
    47	
    48	void trace_and_die(const char* msg) {
    49	  fprintf(stderr, "%s", msg); /* stderr is harder to redirect than stdout */
    50	  exit(EXIT_FAILURE);         /* -1 in stdlib.h */
    51	}
    52	
    53	
    54	
    55	
    56	
    57	
    58	
    59	
    60	
    61	
    62	int main() {
    63	  /* Trap signals generated by arithmetic errors such as 
    64	     division by zero. The statement
    65	     
    66	     signal(SIGINT, SIG_IGN);
    67	
    68	     would instruct the program to ignore (SIG_IGN) interrupts such
    69	     as hitting Control-C while the program is in execution.
    70	
    71	     In this example, we want to suppress floating-point exceptions
    72	     from the system and instead handle the matter ourselves.
    73	
    74	     Withtout this setup, the division of, say, 100 by 0 would generate
    75	     a "floating-point exception" and terminate execution.
    76	  */
    77	 
    78	  printf("SIGFPE is defined as %i\n", SIGFPE);
    79	
    80	  signal(SIGFPE, jumper); /* enable a jump to jumper function on FPE */
    81	  while (0 == guard())    /* loop until error occurs */
    82	    ;                     /* empty statement follows call to guard() */
    83	  return 0;
    84	}
    85	
    86	/* Jump out of this function to the jump destination,
    87	   which is the point after the call to setjmp. In
    88	   our case, the jump point occurs right after the
    89	   if-test in function guard.
    90	*/
    91	void jumper(int status) {
    92	  printf("\t Control to jumper: signal status == %d.\n", status);
    93	  longjmp(env, 1);  /* 1 indicates what setjmp would have returned.
    94			       If successful, longjmp forces control to return
    95			       to the next statement after setjmp, in this case
    96			       a call to divisionInt.
    97			     */
    98	  /* Executed only if longjmp fails, which shouldn't happen. */
    99	  trace_and_die("longjmp returned: trouble\n");
   100	}
   101	
   102	/* Set a jump point for return from an error  condition, in this case 
   103	   an error resulting from a floating-point operation. The function
   104	   signal is invoked in main to trap such errors. Return 0 (ok) if the 
   105	   floating-point operation succeeds; otherwise, the nonlocal jump
   106	   triggered by longjmp intervenes.
   107	*/
   108	int guard(void) {
   109	  /* Set jump point, which is right after the while-test. Here's
   110	     a summary of what happens when the two integers are, say,
   111	     12 and 0, which causes the FPE "division by zero" error. 
   112	        
   113	        -- the signal(SIGFPE, jumper) establishes the jumper 
   114	           function as the callback (event handler) should a
   115	           exception occur
   116	
   117	        -- the guard function (we're in it) is called from the
   118	           infinitie while loop as a test. guard returns 0 to
   119	           signal OK
   120	
   121	
   122	        -- right before calling divisionInt, guard saves the
   123	           current environment, including all of the information
   124	           about the error handling
   125	
   126	        -- if the divisionInt function triggers a division by zero
   127	           exception, then jumper is called by the system
   128	
   129	        -- jumper invokes longjmp with the saved environment. the
   130	           jump is "long" in that divisionInt does not return, as
   131	           normal, to the printf statement at the bottom of guard;
   132	           instead, control resumes immediately after the call to
   133	           guard(), which is the empty statement that is the body
   134	           of the while loop.
   135	
   136	     Here's output from a sample run to illustrate:
   137	
   138		Two integers: 12 5
   139		12 / 5 == 2
   140		Right after divisionInt()....
   141	
   142		Two integers: 12 4
   143		12 / 4 == 3
   144		Right after divisionInt()....
   145	
   146		Two integers: 12 0
   147		Control to jumper: signal status == 8.
   148	
   149		Two integers: 12 2
   150		12 / 2 == 6
   151		Right after divisionInt()....
   152		Two integers: ^C
   153	  */
   154	  setjmp(env);
   155	  divisionInt();
   156	  printf("Right after divisionInt()....\n");
   157	  return 0;
   158	}
   159	
   160	/* Scan the standard input for two floats and divide the first by the second. */
   161	void divisionInt(void) {
   162	  int n1, n2;
   163	  printf("Two integers: ");
   164	  scanf("%i %i", &n1, &n2);
   165	  printf("%i / %i == %i\n", n1, n2, n1 / n2); /* may trigger FPE */
   166	}
   167	
   168	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169	
   170	
   171	
   172	
   173	
   174	
   175	
   176	
   177	
   178	
   179	
   180	
   181	
   182	#include <stdio.h>
   183	
   184	#define N (50)
   185	int main() {
   186	  const float temp = 366.0f;
   187	  const float days_in_year = 365.0f; /* ignore leap years */
   188	  float prob = 1.0f;
   189	
   190	  int i;
   191	  for (i = 1; i <= N; i++) {
   192	    prob *= (temp - i) / days_in_year;
   193	    printf("%4i - %5.3f", i, 1.0f - prob);
   194	    if (i % 5 == 0) printf("\n");
   195	  }
   196	  return 0;
   197	}
   198	/* 
   199	 Probabilities of shared birthdays == cache conflict
   200	
   201	   1 - 0.000   2 - 0.003   3 - 0.008   4 - 0.016   5 - 0.027
   202	   6 - 0.040   7 - 0.056   8 - 0.074   9 - 0.095  10 - 0.117
   203	  11 - 0.141  12 - 0.167  13 - 0.194  14 - 0.223  15 - 0.253
   204	  16 - 0.284  17 - 0.315  18 - 0.347  19 - 0.379  20 - 0.411
   205	  21 - 0.444  22 - 0.476  23 - 0.507  24 - 0.538  25 - 0.569
   206	  26 - 0.598  27 - 0.627  28 - 0.654  29 - 0.681  30 - 0.706
   207	  31 - 0.730  32 - 0.753  33 - 0.775  34 - 0.795  35 - 0.814
   208	  36 - 0.832  37 - 0.849  38 - 0.864  39 - 0.878  40 - 0.891
   209	  41 - 0.903  42 - 0.914  43 - 0.924  44 - 0.933  45 - 0.941
   210	  46 - 0.948  47 - 0.955  48 - 0.961  49 - 0.966  50 - 0.970
   211	
   212	Semantics:
   213	
   214	Among N people (for N from 1 through 50), what is the liklihood that
   215	any will share a birthday? This is the cache collision problem. Note
   216	that, with 23 people, the probability of a shared birthday > 50%.
   217	With 50 people, it's almost a certainty.
   218	*/
   219	
   220	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221	
   222	
   223	
   224	
   225	
   226	
   227	
   228	
   229	
   230	
   231	
   232	
   233	
   234	
   235	
   236	
   237	
   238	
   239	
   240	
   241	
   242	#!/usr/bin/perl -w
   243	
   244	# RGB to Cyan-Magenta-Yellow-Black (CMYK) format.
   245	# For instance, "rosy red" is 188-143-143 in RGB but
   246	# 0-45-45-67 in CMYK
   247	sub rgb_to_cmyk_bf {      # bf for "brute force"
   248	    my ($r, $g, $b) = @_; # 3 arguments: red, green, blue
   249	    my ($c, $m, $y) = (255 - $r, 255 - $g, 255 - $b);
   250	    my $k = ($c < $m) ? ($c < $y ? $c : $y)
   251		              : ($m < $y ? $m : $y);
   252	    for ($c, $m, $y) { 
   253		$_ -= $k; # subtract $k from each
   254	    }
   255	    return [$c, $m, $y, $k]; # an array reference
   256	}
   257	# Take a GIF image that's 1024 (height) by 768 (width) pixels
   258	# for 1024 * 768 = 786,432 pixels in all. Each pixel has an
   259	# RGB value. GIF images are restricted to 256 colors; hence, 
   260	# 786,432 - 256 = 786,176 of the computations will be redundant.
   261	# So here's a better version: one that _caches_ results.
   262	sub rgb_to_cmyk { 
   263	    my ($r, $g, $b) = @_;
   264	
   265	    my $key = join ',', $r, $g, $b; # stringify the three
   266	    # Return if already computed.
   267	    return $cache{$key} if exists $cache{$key};
   268	
   269	    my ($c, $m, $y) = (255 - $r, 255 - $g, 255 - $b);
   270	    my $k = ($c < $m) ? ($c < $y ? $c : $y)
   271		              : ($m < $y ? $m : $y);
   272	    for ($c, $m, $y) { 
   273		$_ -= $k; # subtract $k from each
   274	    }
   275	
   276	    # Otherwise, cache the computed value and return it.
   277	    return $cache{$key} = [$c, $m, $y, $k]; 
   278	}
   279	#  Let f = the amount of time required to call rgb_to_cmyk_bf
   280	#  Let g = the amount of time required for the cache operation
   281	#  Let h = the "hit ratio," the probability that a value has
   282	#          been computed already and therefore is in the cache
   283	#
   284	#  If g > f, there's no point in caching, as g occurs on every call.
   285	#
   286	#  The difference between rgb_to_cmyk_bf and rgb_to_cymk is
   287	#
   288	#       g - hf
   289	#
   290	#  That is, every time you find the goodies in the cache, you
   291	#  save f; and h is the liklihood that you'll find the goodies.
   292	#  At the start, h is 0 but approaches 1 with each cache addition.
   293	#  So if g < hf, caching is worth it.
   294	
   295	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   296	
   297	
   298	
   299	
   300	
   301	
   302	#include <netinet/in.h>
   303	#include <arpa/inet.h>
   304	#include <netdb.h>
   305	#include <sys/socket.h>
   306	#include <stdio.h>
   307	
   308	typedef struct hostent host_info;
   309	
   310	void show_bytes(char* msg, unsigned char* ptr, int how_many) {
   311	  printf("%s\n", msg);
   312	  int i;
   313	  for (i = 0; i < how_many; i++) printf(" %.2x", ptr[i]);
   314	  printf("\n");
   315	}
   316	
   317	void dump_host_aux(host_info* host_ptr) {
   318	  if (host_ptr == NULL) return;
   319	  /* Here's the hostent structure layout:
   320	
   321	     struct hostent {
   322	        char*    h_name;       ;; official name
   323	        char**   h_aliases;    ;; alias list
   324	        int      h_addrtype;   ;; host address type 
   325	        int      h_length;     ;; length of address 
   326	        char**   h_addr_list;  ;; list of addresses 
   327	     };
   328	  */
   329	  printf("\n");
   330	  printf("Official name: %s\n", host_ptr->h_name);
   331	
   332	  printf("Aliases: ");
   333	  int i = 0;
   334	  while (host_ptr->h_aliases[i] != NULL) {
   335	    printf("%.21s\n", host_ptr->h_aliases[i]);
   336	    i++;
   337	  }
   338	  
   339	  int type = host_ptr->h_addrtype;
   340	  const char* type_str = (type == 2) ? "AF_INET" : "AF_INET6";
   341	
   342	  printf("Host type: %s\n", type_str);
   343	
   344	  printf("Address length: %i\n", host_ptr->h_length);
   345	
   346	  printf("Addresses: ");
   347	  i = 0;
   348	  while (host_ptr->h_addr_list[i] != NULL) {
   349	    struct in_addr addr;
   350	    addr.s_addr = *((unsigned int*) host_ptr->h_addr_list[i]);
   351	    if (i > 0) printf("           ");
   352	    printf("%.21s\n", inet_ntoa(addr));
   353	    i++;
   354	  }
   355	  printf("\n");
   356	}
   357	
   358	
   359	
   360	
   361	
   362	void dump_host(const char* host_name) {
   363	  host_info* host = gethostbyname(host_name);
   364	  dump_host_aux(host);
   365	}
   366	
   367	int main() {
   368	
   369	  /* host and network byte order */
   370	  int n = 0xabcdef12;
   371	  show_bytes("IA32 int:", (unsigned char*) &n, sizeof(int));
   372	  unsigned u = htonl(n);
   373	  show_bytes("htonl:", (unsigned char*) &u, sizeof(unsigned));
   374	  u = ntohl(u);
   375	  show_bytes("ntohl:", (unsigned char*) &n, sizeof(int));
   376	  /* output:
   377	
   378	     IA32 int: 12 ef cd ab
   379	     htonl:    ab cd ef 12
   380	     ntohl:    12 ef cd ab
   381	  */
   382	
   383	  /* dotted-decimal addresses in network byte order */
   384	  struct in_addr inet_address;
   385	  int flag = inet_aton("140.192.1.6", &inet_address);
   386	  if (flag) {
   387	    unsigned long addr = inet_address.s_addr;
   388	    show_bytes("inet_aton:", (unsigned char*) &addr, sizeof(unsigned long));
   389	    /*
   390	        inet_aton: 8c c0 01 06 ;; 140 192 1 6
   391	    */
   392	  }
   393	
   394	  /* some lookup stuff */
   395	  dump_host("condor.depaul.edu");
   396	  dump_host("www.google.com");
   397	  dump_host("www.yahoo.com");
   398	  dump_host("localhost");
   399	  /* output:
   400	
   401	    Official name: condor.depaul.edu
   402	    Aliases:
   403	    Host type:AF_INET
   404	    Address length: 4
   405	    Addresses: 140.192.1.6
   406	
   407	    Official name: www.l.google.com
   408	    Aliases: www.google.com
   409	    Host type: AF_INET
   410	    Address length: 4
   411	    Addresses: 72.14.203.104
   412	               72.14.203.99
   413	
   414	
   415	
   416	
   417	
   418	
   419	
   420	
   421	
   422	    Official name: www.yahoo.akadns.net
   423	    Aliases: www.yahoo.com
   424	    Host type: AF_INET
   425	    Address length: 4
   426	    Addresses: 68.142.197.66
   427	               68.142.197.74
   428	               68.142.197.79
   429	               68.142.197.82
   430	               68.142.197.84
   431	               68.142.197.85
   432	               68.142.197.87
   433	               68.142.197.90
   434	
   435	    Official name: localhost.localdomain
   436	    Aliases: localhost
   437	    Host type: AF_INET
   438	    Address length: 4
   439	    Addresses: 127.0.0.1
   440	  */
   441	
   442	  return 0;
   443	}
   444	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   445	
   446	#include <stdio.h>
   447	#include <sys/types.h>
   448	#include <sys/socket.h>
   449	#include <netinet/in.h>
   450	#include <netdb.h> 
   451	
   452	#define BuffSize (4096)
   453	
   454	void error_msg(const char* msg, int halt_flag) {
   455	    perror(msg);
   456	    if (halt_flag) exit(-1);
   457	}
   458	
   459	
   460	
   461	
   462	
   463	
   464	
   465	
   466	
   467	
   468	
   469	
   470	
   471	
   472	
   473	
   474	
   475	
   476	
   477	
   478	
   479	
   480	
   481	
   482	int main() {
   483	  
   484	  const int port = 80;  /* default port for a Web server */
   485	
   486	  /* a very simple GET request */
   487	  const char* request = 
   488	    "GET /~mkalin/index.html HTTP/1.1\nhost: condor.depaul.edu\n\n";
   489	  /* GET /~mkalin/index.html   ;; first-line in request
   490	     host: condor.depaul.edu   ;; first and only line of header, a hash
   491	     <newline>                 ;; two newlines signal end of header
   492	     <newline>
   493	                               ;; a GET request has no body
   494	  */
   495	  
   496	  int sock, n;
   497	  struct sockaddr_in serv_addr;
   498	  struct hostent* server;
   499	  char buffer[BuffSize + 1];
   500	 
   501	  /* get the server information */
   502	  server = gethostbyname("condor.depaul.edu");
   503	  if (server == NULL) error_msg("No such host.", 1);
   504	
   505	  /* create socket descriptor */
   506	  sock = socket(AF_INET,        /* address family */
   507			SOCK_STREAM,    /* type: in this case, TCP based */
   508			0);             /* protocol: 0 means get from 2nd arg */
   509	  if (sock < 0) error_msg("Can't get socket descriptor.", 1);
   510	
   511	  /* fill in the fields of the server's address structure */
   512	  bzero(&serv_addr, sizeof(serv_addr));  /* zero everything out to begin */
   513	  serv_addr.sin_family = AF_INET;        /* address family */
   514	  /* copy from the hostent structure into the server address structure */
   515	  bcopy((unsigned char*) server->h_addr, 
   516		(unsigned char*) &serv_addr.sin_addr.s_addr,
   517		server->h_length);
   518	  serv_addr.sin_port = htons(port); /* host endian to network endian */
   519	
   520	  /* try to connect to the server */
   521	  if (connect(sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) < 0) 
   522	    error_msg("Can't connect.", 1);
   523	
   524	  /* write to the socket */
   525	  n = write(sock, request, strlen(request));
   526	  if (n < 0) error_msg("Can't write to socket.", 0);
   527	
   528	  /* read from the socket and print what comes back from server */
   529	  bzero(buffer, BuffSize + 1);
   530	  n = read(sock, buffer, BuffSize);
   531	  if (n < 0)  error_msg("Can't read from socket.", 0);
   532	  printf("%s\n", buffer);
   533	
   534	  if (close(sock) < 0) error_msg("Can't close socket.", 0);
   535	
   536	  return 0;
   537	}
   538	
   539	
   540	
   541	
   542	/* output
   543	
   544	HTTP/1.1 200 OK
   545	Date: Tue, 29 Jun 2010 20:17:43 GMT
   546	Server: Apache/2.2.3 (Red Hat)
   547	Last-Modified: Sun, 30 May 2010 15:18:57 GMT
   548	ETag: "9c4654-7f0-487d1424b7a40"
   549	Accept-Ranges: bytes
   550	Content-Length: 2032
   551	Connection: close
   552	Content-Type: text/html
   553	
   554	<html>
   555	<title>Home page</title>
   556	
   557	<head>
   558	<style type = "text/css">
   559	    .body  {background-color: rgb(225, 225, 225);}
   560	    .links {text-decoration: none;}
   561	    .bullets {background-color: rgb(225, 225, 225); }
   562	    .raw {background-color: wheat; }
   563	    h3 { color: black;}
   564	    a { text-decoration: none; }
   565	</style>
   566	<title>Textbook and Course Listings</title>
   567	</head>
   568	
   569	<body>
   570	
   571	<p>
   572	<fieldset><legend>Basics</legend>
   573	<span>Marty Kalin</span><br/>
   574	<span>Professor and Associate Dean, College of Computing and Digital Media</span><br/>
   575	<span>DePaul University</span><br/>
   576	<span>1 East Jackson</span><br/>
   577	<span>Chicago, IL 60604</span><br/>
   578	<p>
   579	<span>PhD, Northwestern University</span>
   580	</p>
   581	</fieldset>
   582	</p>
   583	
   584	<p>
   585	<fieldset><legend>Books</legend>
   586	<div><a href="http://oreilly.com/catalog/9780596521127/">
   587	  Java Web Services: Up and Running</a></div>
   588	<div><a HREF="ed3/">Applications Programming in ANSI C (3rd edition)</a><div>
   589	<div><a HREF="cse/">C for Scientists and Engineers</a><div>
   590	<div><a HREF="apc/">Applications Programming in C++</a><div>
   591	<div><a HREF="oop2/">Object-Oriented Programming in C++ (2nd edition)</a><div>
   592	<div><a HREF="oopj/">Object-Oriented Programming in Java</a><div>
   593	</field
   594	
   595	*/
   596	
