Raymond ElwardCSC 37324 June 2010Homework 1

1)
a) No it is not always 1.  The first test I ran was setting n1 to INT_MIN and n2 to INT_MAX.  From this data the result printed 0.  From looking over the data the 0 comes about because -INT_MIN is out of bounds.  It does this because -INT_MIN takes the 2s complement of INT_MIN creating a integer overflow.

b) Yes 0 will always be the result.  From looking at different outputs and inputs the left side of the == will always be 1 off from the right side.  They with never be equivalent to create TRUE(1) as the result.  This is so because 1s complement is at work here.  in essence 1s complement offsets a number by 1 and there are 2 1s complements at work on the left and only 1 on the right.

c) Yes 1 will always be the result.  The equation here will move the bit string to the right by 1-bit and then shifts it back left by the 1-bit, essentially simply changing the least significant bit into 0 (or keeping it at 0).  So the result of ((n1 >> 1) << 1) will always be unchanged or decremented slightly, so it will always be equal to or less than n1.

d) Yes 1 will always be the result.  With this statement I used some algebra interpretation to turn "((int) (u1 - u2))" into essentially "n1 - n2" (when looking at the bits n1==u1 and n2==u2) which is equivalent to -(n2-n1) = -n2--n1 = -n2+n1 = n1 - n2.

2) The most lucid way I think for me to explain what the mystery function does is that it goes to a at its address at b.  That is b + ptr, which is 2 bytes over from the position of a(or any number of bytes over as long as its a number with in bounds, which the if statement in the function will change an out of bounds b argument to 0) and in that case the function will just replace the byte the pointer specifically points to which will be different on little endian machines vs big endian and replaces what is in that byte.  The better name might be "put_c_in_a_at_position_b".

The easiest way I found to see this is by looking at the HEX representation of the integers.  in the example output given with the function n was set to 0x12345678(305419896) and c was set to 0xab.  b was input as 2.  2 8-bit positions into n is the place holding 0x34.  Thus the value of result comes out to be 0x12ab5678(313218680).3) For this problem the function mystery get an integer n and then completely swaps the HEX value positions.  In essence it changes the representation of a small endian to a large endian value on the intel I used to work on it.  For example this function could be used to change int data when an intel was going to send data to a ppc, and vice versa.In the example input/output shown 1234 becomes -771489792 on the same machine.  when looking at the HEX values it becomes obvious though. 1234(0x4d2) becomes -771489792(0xd2040000).  every 8 bit hex block is switched around.  Specifically the statement in line 25 accomplishes this by shifting the 32-bits around in a mirrored fashion. A better name for this mystery function could be "switch_from_one_endian_to_the_other".